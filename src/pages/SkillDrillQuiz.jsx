import React, { useState, useEffect, useRef } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { useReview } from '../contexts/ReviewContext';
import { Container, Button, Card, ProgressBar, Alert, Spinner } from 'react-bootstrap';
import { doc, getDoc, addDoc, updateDoc, collection, serverTimestamp, setDoc } from 'firebase/firestore';
import { db } from '../firebase/config';
import { normalizeSubcategoryName, getHumanReadableSubcategory } from '../utils/subcategoryUtils';
import { generateSkillQuiz, generateLesson } from '../utils/openaiService';
import { logUserEngagement } from '../utils/analyticsService';
import { processTextMarkup } from '../utils/textProcessing';
import '../styles/SkillDrillQuiz.css';

/**
 * SkillDrillQuiz Component
 * Displays a focused 5-question quiz on a specific skill that the student needs to review
 * Questions are generated by an LLM and tailored to the specific skill gap
 */
const SkillDrillQuiz = () => {
  const { skillTag } = useParams();
  const { currentUser } = useAuth();
  const { markSkillAsReviewed } = useReview();
  const navigate = useNavigate();
  
  // State for quiz data
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [quiz, setQuiz] = useState(null);
  const [questions, setQuestions] = useState([]);
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [userAnswers, setUserAnswers] = useState({});
  const [quizStarted, setQuizStarted] = useState(false);
  const [quizCompleted, setQuizCompleted] = useState(false);
  const [results, setResults] = useState(null);
  const [isGenerating, setIsGenerating] = useState(false);
  
  // Timer reference
  const questionStartTimeRef = useRef(null);
  
  useEffect(() => {
    const loadQuizData = async () => {
      if (!currentUser || !skillTag) {
        navigate('/progress');
        return;
      }
      
      try {
        setLoading(true);
        
        // First check if a quiz for this skill tag already exists
        const skillQuizzesRef = doc(db, 'skillQuizzes', skillTag);
        const skillQuizzesDoc = await getDoc(skillQuizzesRef);
        
        if (skillQuizzesDoc.exists()) {
          // Found an existing quiz for this skill
          const quizData = skillQuizzesDoc.data();
          
          // Set quiz data
          setQuiz(quizData);
          setQuestions(quizData.questions || []);
          
          setLoading(false);
          
        } else {
          // No existing quiz found - we need to generate one
          setIsGenerating(true);
          
          // Retrieve the question data from userNeedsReview if available
          const reviewRef = doc(db, 'userNeedsReview', currentUser.uid, 'skills', skillTag);
          const reviewDoc = await getDoc(reviewRef);
          
          if (reviewDoc.exists() && reviewDoc.data().questionData) {
            const questionData = reviewDoc.data().questionData;
            await generateNewQuiz(questionData);
          } else {
            // No question data available, generate a quiz based on the skill tag only
            await generateNewQuizFromSkillTag(skillTag);
          }
        }
      } catch (error) {
        console.error('Error loading quiz data:', error);
        setError('Error loading quiz: ' + error.message);
        setLoading(false);
      }
    };
    
    loadQuizData();
  }, [currentUser, skillTag, navigate]);
  
  // Scroll to top when quiz is completed
  useEffect(() => {
    if (quizCompleted) {
      window.scrollTo(0, 0);
    }
  }, [quizCompleted]);
  
  // Generate a new quiz from a question the student got wrong
  const generateNewQuiz = async (questionData) => {
    try {
      console.log('Generating new quiz for question:', questionData);
      
      const subcategory = questionData.subcategory || skillTag;
      
      // Try to get quiz from Firestore first
      try {
        const quizRef = doc(db, 'skillQuizzes', subcategory);
        const quizDoc = await getDoc(quizRef);
        
        if (quizDoc.exists()) {
          console.log('Found cached quiz in Firestore');
          const quizData = quizDoc.data();
          setQuiz(quizData);
          setQuestions(quizData.questions || []);
          setIsGenerating(false);
          setLoading(false);
          return;
        }
      } catch (cacheErr) {
        console.warn('Failed to check Firestore cache:', cacheErr);
      }
      
      // Generate a new quiz using direct API call
      console.log('Generating new quiz via direct API call');
      let quizData;
      
      try {
        // Use our openaiService to generate the quiz directly
        quizData = await generateSkillQuiz({
          subcategory: subcategory,
          questionText: questionData.text
        });
        
        console.log('Generated quiz via direct API:', quizData);
      } catch (apiError) {
        console.error('Error generating quiz via API:', apiError);
        // Re-throw the error to be handled by the outer catch block
        throw apiError;
      }
      
      // Update state with the generated quiz
      setQuiz(quizData);
      setQuestions(quizData.questions || []);
      setIsGenerating(false);
      setLoading(false);
      
      // Create a record of this quiz in the user's drills
      const drillRef = await addDoc(collection(db, 'userSkillDrills', currentUser.uid, 'drills'), {
        skillTag: quizData.skillTag,
        skillName: quizData.skillName,
        createdAt: serverTimestamp(),
        completed: false,
        score: 0
      });
      
      // Update the quiz with the drill ID
      await updateDoc(doc(db, 'skillQuizzes', skillTag), {
        drillId: drillRef.id
      });
      
    } catch (error) {
      console.error('Error generating quiz:', error);
      setError('Failed to generate quiz: ' + error.message);
      setIsGenerating(false);
      setLoading(false);
    }
  };
  
  // Generate a new quiz from just the skill tag using direct API calls
  const generateNewQuizFromSkillTag = async (skillTag) => {
    try {
      // First ensure we have a lesson for this skill
      const lessonRef = doc(db, 'lessons', skillTag);
      const lessonDoc = await getDoc(lessonRef);
      
      if (!lessonDoc.exists()) {
        // No lesson exists yet, let's generate one via the API
        console.log('No lesson exists yet, generating one via API');
        try {
          // Generate a lesson using the OpenAI API
          const lessonData = await generateLesson(skillTag);
          
          // Save the generated lesson to Firestore
          await setDoc(lessonRef, lessonData);
          console.log('Created and saved new lesson to Firestore');
        } catch (lessonError) {
          console.error('Failed to generate lesson:', lessonError);
          throw new Error(`Failed to create lesson for ${skillTag}: ${lessonError.message}`);
        }
      }
      
      // Now generate quiz questions for this skill
      console.log('Generating quiz for skill tag:', skillTag);
      console.log('Human-readable name:', getHumanReadableSubcategory(skillTag));
      
      let quizData;
      
      // Try to get quiz from Firestore first
      try {
        const quizRef = doc(db, 'skillQuizzes', skillTag);
        const quizDoc = await getDoc(quizRef);
        
        if (quizDoc.exists()) {
          console.log('Found cached quiz in Firestore');
          quizData = quizDoc.data();
        } else {
          // Generate a new quiz with direct API call
          try {
            console.log('Generating new quiz via direct API call');
            quizData = await generateSkillQuiz({
              subcategory: skillTag,
              questionText: `Practice questions for ${getHumanReadableSubcategory(skillTag)}`
            });
            
            // Save to Firestore
            await setDoc(quizRef, quizData);
            console.log('Generated quiz data and saved to Firestore:', quizData);
          } catch (error) {
            console.error('Error generating quiz via API:', error);
            // Re-throw the error to be handled by the outer catch block
            throw new Error(`Failed to generate quiz: ${error.message}`);
          }
        }
      } catch (error) {
        console.error('Error fetching quiz:', error);
        throw new Error(`Failed to fetch or generate quiz: ${error.message}`);
      }
      
      // Update state with the generated quiz
      setQuiz(quizData);
      setQuestions(quizData.questions || []);
      setIsGenerating(false);
      setLoading(false);
      
      // Create a record of this quiz in the user's drills
      const drillRef = await addDoc(collection(db, 'userSkillDrills', currentUser.uid, 'drills'), {
        skillTag: quizData.skillTag,
        skillName: quizData.skillName,
        createdAt: serverTimestamp(),
        completed: false,
        score: 0
      });
      
      // Update the quiz with the drill ID
      await updateDoc(doc(db, 'skillQuizzes', skillTag), {
        drillId: drillRef.id
      });
      
    } catch (error) {
      console.error('Error generating quiz from skill tag:', error);
      setError('Failed to generate quiz: ' + error.message);
      setIsGenerating(false);
      setLoading(false);
    }
  };
  
  // Start the quiz
  const handleStartQuiz = () => {
    setQuizStarted(true);
    questionStartTimeRef.current = new Date();
    
    // Track that the user started a skill drill
    if (currentUser && skillTag) {
      const normalizedTag = normalizeSubcategoryName(skillTag);
      logUserEngagement(currentUser.uid, 'start_drill', normalizedTag, {
        quizId: quiz?.id || skillTag,
        skillName: quiz?.skillName || getHumanReadableSubcategory(skillTag)
      }).catch(err => console.error('Analytics error:', err));
    }
  };
  
  // Handle user selecting an answer
  const handleAnswerSelected = (questionId, selectedOption) => {
    if (quizCompleted) return;
    
    const currentQuestion = questions.find(q => q.id === questionId);
    if (!currentQuestion) return;
    
    const isCorrect = selectedOption === currentQuestion.correctAnswer;
    const timeSpent = Math.round((new Date() - questionStartTimeRef.current) / 1000);
    
    // Record answer
    setUserAnswers(prev => ({
      ...prev,
      [questionId]: {
        questionId,
        selectedOption,
        isCorrect,
        timeSpent,
        submittedAt: new Date()
      }
    }));
    
    // Check if this was the last question
    if (currentQuestionIndex === questions.length - 1) {
      completeQuiz();
    } else {
      // Move to next question
      setCurrentQuestionIndex(prev => prev + 1);
      questionStartTimeRef.current = new Date();
    }
  };
  
  // Complete the quiz
  const completeQuiz = async () => {
    try {
      // Calculate results
      const totalQuestions = questions.length;
      const answeredQuestions = Object.keys(userAnswers).length;
      const correctAnswers = Object.values(userAnswers).filter(a => a.isCorrect).length;
      const score = Math.round((correctAnswers / totalQuestions) * 100);
      
      const resultsData = {
        totalQuestions,
        answeredQuestions,
        correctAnswers,
        score,
        skillTag: quiz.skillTag,
        skillName: quiz.skillName,
        completedAt: new Date()
      };
      
      setResults(resultsData);
      setQuizCompleted(true);
      
      // Update user's drill record
      if (quiz.drillId) {
        await updateDoc(doc(db, 'userSkillDrills', currentUser.uid, 'drills', quiz.drillId), {
          completed: true,
          score,
          completedAt: serverTimestamp(),
          answers: userAnswers
        });
        
        // Track that the user completed a skill drill
        if (currentUser && skillTag) {
          const normalizedTag = normalizeSubcategoryName(skillTag);
          logUserEngagement(currentUser.uid, 'complete_drill', normalizedTag, {
            quizId: quiz?.id || skillTag,
            skillName: quiz?.skillName || getHumanReadableSubcategory(skillTag),
            score,
            correctAnswers,
            totalQuestions
          }).catch(err => console.error('Analytics error:', err));
        }
      }
      
      // Mark the skill as reviewed (this will update the due date)
      await markSkillAsReviewed(skillTag);
      
    } catch (error) {
      console.error('Error completing quiz:', error);
      setError('Error saving results: ' + error.message);
    }
  };
  
  // Handle returning to progress dashboard
  const handleBackToProgress = () => {
    navigate('/progress');
  };
  
  // Handle viewing the lesson before practicing
  const handleViewLesson = () => {
    navigate(`/lesson/${skillTag}`);
  };
  
  // Loading state
  if (loading) {
    return (
      <div className="skill-drill-container">
        <div className="loading-container">
          <Spinner animation="border" role="status" />
          <p>{isGenerating ? 'Generating personalized skill practice...' : 'Loading practice questions...'}</p>
          {isGenerating && <p className="generating-info">This may take a moment as we create tailored practice questions just for you.</p>}
        </div>
      </div>
    );
  }
  
  // Error state
  if (error) {
    return (
      <div className="skill-drill-container">
        <Alert variant="danger">
          <Alert.Heading>Error</Alert.Heading>
          <p>{error}</p>
        </Alert>
        <Button variant="primary" onClick={handleBackToProgress}>
          Back to My Progress
        </Button>
      </div>
    );
  }
  
  // No questions available
  if (!questions || questions.length === 0) {
    return (
      <div className="skill-drill-container">
        <Alert variant="warning">
          <Alert.Heading>No Questions Available</Alert.Heading>
          <p>We couldn't find any practice questions for this skill. Please try again later.</p>
        </Alert>
        <Button variant="primary" onClick={handleBackToProgress}>
          Back to My Progress
        </Button>
      </div>
    );
  }
  
  // Quiz completed state
  if (quizCompleted && results) {
    return (
      <div className="skill-drill-container">
        <div className="skill-drill-header">
          <h1>Practice Complete</h1>
          <h2>{quiz.skillName}</h2>
        </div>
        
        <div className="skill-drill-results">
          <div className="score-display">
            <div className={`score-circle ${results.score >= 70 ? 'passed' : 'needs-work'}`}>
              {results.score}%
            </div>
          </div>
          
          <div className="results-details">
            <p>You answered <strong>{results.correctAnswers}</strong> out of <strong>{results.totalQuestions}</strong> questions correctly.</p>
            
            <div className="skill-explanation">
              <h3>Skill Summary</h3>
              <p>{quiz.explanation}</p>
              
              {quiz.commonError && (
                <div className="common-error">
                  <h4>Common Mistake</h4>
                  <p>{quiz.commonError}</p>
                </div>
              )}
            </div>
            
            <div className="question-review">
              <h3>Review Your Answers</h3>
              {questions.map((question, index) => {
                const answer = userAnswers[question.id];
                const isCorrect = answer?.isCorrect || false;
                
                return (
                  <div 
                    key={question.id} 
                    className={`question-item ${isCorrect ? 'correct' : 'incorrect'}`}
                  >
                    <div className="question-number">Question {index + 1}</div>
                    <div 
                      className="question-text"
                      dangerouslySetInnerHTML={{ __html: processTextMarkup(question.text) }}
                    />
                    <div className="question-result">
                      {isCorrect ? 
                        <span className="correct-label">Correct</span> : 
                        <span className="incorrect-label">Incorrect</span>
                      }
                    </div>
                    <div className="question-explanation">
                      <h4>Explanation</h4>
                      <p dangerouslySetInnerHTML={{ __html: processTextMarkup(question.explanation) }} />
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
          
          <div className="navigation-buttons">
            <Button variant="primary" onClick={handleViewLesson}>
              View Lesson
            </Button>
            <Button variant="secondary" onClick={handleBackToProgress}>
              Back to My Progress
            </Button>
          </div>
        </div>
      </div>
    );
  }
  
  // Quiz active state (started but not completed)
  if (quizStarted && !quizCompleted) {
    const currentQuestion = questions[currentQuestionIndex];
    
    return (
      <div className="skill-drill-container">
        <div className="skill-drill-header">
          <h1>
            Skill Practice: {quiz.skillName}
            {window.location.hostname === 'localhost' && <small className="text-muted ms-2">(Development Mode)</small>}
          </h1>
          <div className="progress-tracker">
            Question {currentQuestionIndex + 1} of {questions.length}
          </div>
        </div>
        
        <div className="question-container">
          <div className="question-text">
            <div dangerouslySetInnerHTML={{ __html: processTextMarkup(currentQuestion.text) }} />
            
            {/* Display graph description if available */}
            {currentQuestion.graphDescription && (
              <div className="question-graph-description">
                <div className="graph-description-label">Graph Description:</div>
                <div 
                  className="graph-description-content"
                  dangerouslySetInnerHTML={{ __html: processTextMarkup(currentQuestion.graphDescription) }}
                />
              </div>
            )}
            
            {/* Display graph if one exists */}
            {currentQuestion.graphUrl && (
              <div className="question-graph-container">
                <img 
                  src={currentQuestion.graphUrl} 
                  alt="Graph for question" 
                  className="question-graph" 
                />
              </div>
            )}
          </div>
          
          <div className="options-container">
            {currentQuestion.options.map((option, index) => (
              <button
                key={index}
                className="option-button"
                onClick={() => handleAnswerSelected(currentQuestion.id, index)}
              >
                <span className="option-letter">{String.fromCharCode(65 + index)}</span>
                <span className="option-text">{option}</span>
              </button>
            ))}
          </div>
        </div>
      </div>
    );
  }
  
  // Quiz intro state (not started yet)
  return (
    <div className="skill-drill-container">
      <div className="skill-drill-header">
        <h1>Skill Practice</h1>
        <h2>{quiz.skillName}</h2>
      </div>
      
      <div className="skill-intro">
        <div className="skill-explanation">
          <h3>About This Skill</h3>
          <p>{quiz.explanation}</p>
          
          {quiz.commonError && (
            <div className="common-error">
              <h4>Common Mistake</h4>
              <p>{quiz.commonError}</p>
            </div>
          )}
        </div>
        
        <div className="practice-instructions">
          <h3>Practice Instructions</h3>
          <p>This practice set contains {questions.length} questions focused specifically on {quiz.skillName}.</p>
          <p>Each question is designed to help you improve this particular skill. After the practice, you'll receive detailed explanations for each question.</p>
        </div>
        
        <div className="quiz-actions">
          <Button variant="primary" onClick={handleStartQuiz} className="start-button">
            Start Practice
          </Button>
          <Button variant="outline-secondary" onClick={handleViewLesson} className="lesson-button">
            View Lesson First
          </Button>
          <Button variant="link" onClick={handleBackToProgress}>
            Back to My Progress
          </Button>
        </div>
      </div>
    </div>
  );
};

export default SkillDrillQuiz;
